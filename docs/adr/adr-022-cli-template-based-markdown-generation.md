---
aliases:
  - /_uid/7a0d4b9f-6d3c-4a66-a7d0-1b8bfe8f2e1c/
categories:
  - architecture-decisions
date: 2026-02-01T00:00:00Z
fingerprint: 17a7279a92bc5cf5f06a169b0ccadee747f84703d329f347a6d9080e72882e66
lastmod: "2026-02-01"
tags:
  - cli
  - templates
  - authoring
  - markdown
  - ux
uid: 7a0d4b9f-6d3c-4a66-a7d0-1b8bfe8f2e1c
---

# ADR-022: CLI template-based markdown file creation

**Status**: Proposed  
**Date**: 2026-02-01  
**Decision Makers**: DocBuilder Core Team

## Decision summary

DocBuilder will add a CLI command that can **discover**, **select**, and **instantiate** documentation templates hosted inside the documentation site itself.

- Templates are authored as normal documentation pages.
- Templates are discovered via the rendered site’s taxonomy listing: `GET <baseURL>/categories/templates`.
- A selected template is fetched as rendered HTML and parsed to extract:
  - **template metadata** (from `head > meta[property][content]`)
  - the **template body** (a fenced Markdown code block rendered into HTML)
- The CLI prompts the user for any declared inputs, renders the template, suggests a filename, and writes the new Markdown file.
- Generated files are written under the local repository’s `docs/` directory by default, using a template-provided suggested relative path.
- After writing a file, the command automatically runs `docbuilder lint --fix` on the generated file to satisfy DocBuilder’s frontmatter invariants.
- The feature supports a single template discovery base URL.
- DocBuilder-generated documentation sites emit the required `docbuilder:*` metadata into the rendered HTML automatically (no user-managed Hugo partials).

## Context and problem statement

DocBuilder has strong support for building and validating documentation, but it does not provide a first-class workflow for creating *new* documentation pages in a consistent style.

We want to enable a lightweight “authoring assistant” workflow:

- A contributor runs a CLI command.
- The CLI shows the set of available template types.
- The contributor selects a template and fills in a few values (title, tags, categories, etc.).
- The CLI generates a new Markdown file with standardized frontmatter and structure.

The key constraint is that templates are not external assets shipped with the binary. Instead, templates are defined *within the documentation itself* (and therefore versioned and reviewed like documentation).

## Goals

- Make it easy to create new documentation pages using curated templates.
- Keep templates versioned, reviewable, and discoverable as part of the docs corpus.
- Keep the CLI behavior deterministic and auditable (no “magic” edits).
- Allow template authors to define:
  - the visible template name
  - default values and required fields
  - a filename suggestion rule

## Non-goals

- A general-purpose scaffolding system for arbitrary file types (only Markdown output).
- A full interactive TUI (keep prompts simple and dependency-light).
- Executing arbitrary code from templates.
- Editing existing documents.

## Decision

Introduce a new CLI surface (names illustrative):

- `docbuilder template list` — list available templates from a docs site.
- `docbuilder template new` — select a template and write a new Markdown file.

Template discovery and parsing will be based on the rendered documentation site.

### Why rendered HTML instead of raw Markdown sources?

- The rendered site provides a stable discovery surface (`/categories/templates`) even if repositories / source paths vary.
- The rendered page contains normalized, theme-consistent HTML for code blocks and metadata.
- This allows templates to be hosted remotely (e.g., a published docs site) without requiring the CLI to clone source repositories.

### Runtime injection: emitting `docbuilder:*` meta tags

The CLI expects `docbuilder:*` metadata to be present as HTML meta tags (`head > meta[property][content]`).

To ensure this works without any manual theme customization, DocBuilder will inject the required Relearn head hook **at site generation time**.

- DocBuilder writes `layouts/partials/custom-header.html` into the generated Hugo site.
- That partial emits `docbuilder:*` meta tags for pages that carry template metadata in their frontmatter.
- This is a DocBuilder-managed file; users are not expected to create or maintain it.

Implication:

- Template discovery base URLs should point to documentation sites that were generated by DocBuilder (or otherwise implement the same contract).

## Template definition contract

### Prerequisite: DocBuilder-generated (or compatible) site

The template discovery base URL must point to a documentation site generated by DocBuilder.

Rationale:

- DocBuilder injects a Relearn head hook (`layouts/partials/custom-header.html`) that emits `docbuilder:*` metadata as `head > meta[property][content]`.
- The template CLI depends on those meta tags for reliable parsing.

If a non-DocBuilder site is used, it must explicitly implement the same contract (emit the same meta tags and expose templates under `categories/templates`).

### 1) Source documents

A template is a documentation page that meets *all* criteria:

- It is categorized as `Templates` in frontmatter (taxonomy page is `categories/templates`).
- Its source filename follows the convention: `[TEMPLATE_TYPE].template.md`.
- The page content includes **exactly one** fenced Markdown code block that represents the template to instantiate.

### 2) Discovery page contract

The template list is retrieved from:

- `GET <baseURL>/categories/templates/` (accept both with and without trailing slash)

Links to templates are discovered by scanning anchors matching the pattern:

- `a[href*=".template/"]`

Example (as rendered HTML):

```html
<a href="/path/to/template/adr.template/index.html">adr.template</a>
```

The CLI should derive `templateType` from the anchor text (or last path segment) by stripping the `.template` suffix.

### 3) Metadata contract (HTML meta tags)

Template metadata is retrieved from:

- `head > meta[property][content]`

We will reserve `docbuilder:` namespaced meta properties for template behavior.

Minimum recommended properties:

- `docbuilder:template.type` (string): canonical template type (e.g., `adr`)
- `docbuilder:template.name` (string): human-friendly display name
- `docbuilder:template.output_path` (string): suggested output path pattern, relative to `docs/`

Optional properties:

- `docbuilder:template.description` (string)
- `docbuilder:template.schema` (string): a JSON schema-like structure for prompts
- `docbuilder:template.defaults` (string): JSON object of defaults

**Rationale:** meta tags are accessible in the rendered HTML without depending on theme-specific body structure.

### Template authoring: frontmatter source of truth (Relearn)

Template documents encode the meta values in their frontmatter under `params.docbuilder.template.*` (Option B). DocBuilder’s injected `custom-header.html` partial is responsible for converting these values into HTML meta tags.

Example (illustrative):

```yaml
---
title: "ADR template"
categories:
  - Templates

params:
  docbuilder:
    template:
      type: "adr"
      name: "Architecture Decision Record"
      output_path: "adr/adr-{{ printf \"%03d\" .NextADRNumber }}-{{ .Slug }}.md"
      description: "Scaffold a new ADR under docs/adr/."
      schema: '{"fields":[{"key":"Title","type":"string","required":true},{"key":"Slug","type":"string","required":true}]}'
      defaults: '{"categories":["architecture-decisions"]}'
---
```

### 4) Template body contract (rendered code block)

The template body is extracted from the rendered HTML by selecting the first code block matching:

- `pre > code.language-markdown`, `pre > code.language-md`, or `pre > code` whose class indicates Markdown

The CLI uses the text content of that `<code>` node as the template source.

If multiple Markdown code blocks exist, the CLI must fail with a clear error, unless template metadata explicitly marks the correct block (future extension).

## Template rendering and prompting

### Rendering engine

Use Go’s `text/template` for template rendering (string substitution), with a small and safe function surface.

- No file I/O from templates.
- No network access from templates.
- No dynamic code execution.

### Prompting contract

If `docbuilder:template.schema` is present, the CLI prompts for each declared field.

Supported field types (initial set):

- `string`
- `string_enum` (select-one)
- `string_list` (comma-separated input)
- `bool`

The CLI should allow non-interactive overrides:

- `--set key=value` (repeatable)
- `--defaults` (use declared defaults and skip prompts)

### Frontmatter and filename suggestion

- The generated Markdown content should include YAML frontmatter.
- The output location suggestion comes from `docbuilder:template.output_path` and is interpreted as a path under `docs/`.
  - Example (ADR): `adr/adr-{{ printf "%03d" .NextADRNumber }}-{{ .Slug }}.md`

The CLI must always show the final destination path and confirm before writing, unless `--yes` is set.

### Sequence helpers: `nextInSequence(name)`

DocBuilder exposes a template helper `nextInSequence(name)` to support sequential numbering patterns beyond ADRs.

- `name` identifies a configured sequence (e.g., `"adr"`).
- The helper returns the next integer in that sequence (starting from 1 if no matches exist).

#### Sequence configuration shape

Sequences are defined by the template itself (as part of template metadata) using a structured object under `params.docbuilder.template.sequence`.

Schema (conceptual):

- `name` (string, required): identifier passed to `nextInSequence(name)`
- `dir` (string, required): directory relative to `docs/` to scan (e.g., `"adr"`)
- `glob` (string, required): filename glob applied within `dir` (e.g., `"adr-*.md"`)
- `regex` (string, required): regular expression applied to each matched filename to extract the sequence number
  - must include exactly one capturing group that yields the integer
- `width` (int, optional): display width for padding (e.g., 3 for `001`); used by templates for formatting
- `start` (int, optional): starting number if no matches exist (default: 1)

DocBuilder will treat this as the canonical definition of how to compute the “next number” for a given sequence.

Example:

```yaml
params:
  docbuilder:
    template:
      type: "adr"
      name: "Architecture Decision Record"
      output_path: "adr/adr-{{ printf \"%03d\" (nextInSequence \"adr\") }}-{{ .Slug }}.md"
      sequence:
        name: "adr"
        dir: "adr"
        glob: "adr-*.md"
        regex: "^adr-(\\d{3})-"
        width: 3
        start: 1
```

Notes:

- `output_path` may reference `nextInSequence("adr")` directly; there is no requirement to define a special `NextADRNumber` variable.
- The regex is evaluated against the **filename** (not the full path).

#### Guardrails (filesystem scanning)

Because sequence scanning reads from the local filesystem, DocBuilder must enforce these guardrails:

- **Rooted under docs**: `dir` must resolve to a path under the local `docs/` directory.
  - reject absolute paths
  - reject any path containing `..` segments
- **Scoped globbing**: `glob` is applied only within `docs/<dir>/` (not across the entire repo).
- **Bounded work**: enforce a maximum number of files to consider per sequence (e.g., 10,000) and fail with a clear error if exceeded.
- **Bounded parsing**: `regex` must compile successfully and must have exactly one capturing group.
  - if a filename matches `glob` but does not match `regex`, it is ignored (not an error)
- **Safe numbers**: parsed sequence numbers must be positive integers; values that overflow `int` are ignored.
- **Deterministic result**: next value is `max(parsed)+1`, or `start` if no values were parsed.

Initial built-in sequence:

- `nextInSequence("adr")` is supported out of the box even if `params.docbuilder.template.sequence` is missing, using the ADR convention under `docs/adr/`.

If a template provides an explicit `sequence` object for `name: "adr"`, that definition takes precedence.

## Configuration and base URL selection

The command needs a base URL to a rendered documentation site.

Resolution order:

1. `--base-url` flag (explicit)
2. `DOCBUILDER_TEMPLATE_BASE_URL` environment variable
3. If `-c/--config` is provided and config includes `hugo.base_url`, use that
4. Error with guidance

Only one base URL is supported at a time.

## Error handling and UX

- Discovery failures should be actionable (include URL, HTTP status, and next step).
- Parsing failures should explain what contract was violated:
  - missing taxonomy page
  - no template links discovered
  - template page missing the markdown code block
  - required meta properties missing

In interactive mode:

- Print templates as a numbered list.
- Let users select by number (and optionally filter by substring as a follow-up enhancement).

## Security and trust model

Templates are treated as **untrusted input**.

- Fetching URLs must be bounded:
  - only `http`/`https`
  - follow redirects only within the same host (or disable redirects initially)
  - enforce reasonable timeouts and max response sizes
- Rendering must be sandboxed to string templating only.
- The CLI must never execute embedded scripts or interpret HTML.

This feature assumes users intentionally point the CLI at a trusted documentation site.

## Alternatives considered

1. Store templates inside the DocBuilder binary
   - Pros: no network, deterministic
   - Cons: templates become code releases instead of docs changes

2. Fetch raw Markdown from git repositories
   - Pros: avoids HTML parsing
   - Cons: requires cloning/auth and duplicates DocBuilder’s build/discovery concerns

3. Use Hugo data files (`data/templates/*.yaml`) instead of docs pages
   - Pros: structured inputs
   - Cons: less discoverable and less “docs-native”

## Open questions

- Do we need a stable identifier beyond `template.type` (e.g., `uid`) for templates?

## Acceptance criteria

- `docbuilder template list --base-url <url>` prints a stable list of templates.
- `docbuilder template new --base-url <url>` lets the user select a template, prompts for fields, and writes a file.
- `docbuilder template list` and `docbuilder template new` can also use `DOCBUILDER_TEMPLATE_BASE_URL`.
- The output file is written under `docs/` and then the command runs `docbuilder lint --fix` on the generated file.
