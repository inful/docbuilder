package transforms

import (
	"fmt"
	"sort"

	"git.home.luguber.info/inful/docbuilder/internal/plugin"
)

// TransformStage represents when a transform should be applied.
type TransformStage string

const (
	// StagePreProcess: Applied before markdown parsing
	StagePreProcess TransformStage = "preprocess"

	// StagePostProcess: Applied after markdown parsing
	StagePostProcess TransformStage = "postprocess"

	// StageFrontmatter: Applied to frontmatter/metadata only
	StageFrontmatter TransformStage = "frontmatter"

	// StageContent: Applied to content only
	StageContent TransformStage = "content"
)

// TransformResult represents the result of a transform operation.
type TransformResult struct {
	// Content is the transformed content
	Content []byte

	// Metadata is any metadata to update/add
	Metadata map[string]interface{}

	// Skipped indicates if the transform was skipped
	Skipped bool

	// Error is any error that occurred
	Error error
}

// TransformInput represents input to a transform.
type TransformInput struct {
	// FilePath is the source file path
	FilePath string

	// Content is the file content
	Content []byte

	// Metadata is the parsed frontmatter/metadata
	Metadata map[string]interface{}

	// Config is the transform-specific configuration
	Config map[string]interface{}
}

// TransformPlugin extends the base Plugin interface with transform-specific methods.
// DEPRECATED: Use TransformPluginV2 for new transforms.
type TransformPlugin interface {
	plugin.Plugin

	// Stage returns when this transform should be applied.
	Stage() TransformStage

	// Dependencies returns the dependency constraints for this transform.
	Dependencies() TransformDependencies

	// ShouldApply returns true if the transform should apply to the given input.
	ShouldApply(input *TransformInput) bool

	// Apply executes the transform on the input.
	// Returns a TransformResult with the transformed content and any metadata updates.
	Apply(input *TransformInput) *TransformResult
}

// TransformDependencies declares explicit ordering constraints for plugin transforms.
type TransformDependencies struct {
	// MustRunAfter lists transform plugin names that must complete before this one
	MustRunAfter []string

	// MustRunBefore lists transform plugin names that must run after this one
	MustRunBefore []string
}

// TransformPluginV2 is the new dependency-based plugin transform interface.
// BaseTransformPlugin provides default implementations for transform lifecycle methods.
type BaseTransformPlugin struct {
	plugin.BasePlugin
}

// ShouldApply returns true by default (applies to all files).
func (b *BaseTransformPlugin) ShouldApply(input *TransformInput) bool {
	return true
}

// TransformRegistry manages transform plugin registration and execution.
type TransformRegistry struct {
	transforms []TransformPlugin
}

// NewTransformRegistry creates a new transform registry.
func NewTransformRegistry() *TransformRegistry {
	return &TransformRegistry{
		transforms: make([]TransformPlugin, 0),
	}
}

// Register adds a transform plugin to the registry.
func (r *TransformRegistry) Register(transform TransformPlugin) error {
	if transform == nil {
		return fmt.Errorf("cannot register nil transform")
	}

	metadata := transform.Metadata()
	if err := metadata.Validate(); err != nil {
		return fmt.Errorf("invalid transform metadata: %w", err)
	}

	// Verify it's a transform type
	if metadata.Type != plugin.PluginTypeTransform {
		return fmt.Errorf("plugin %s has type %s, expected %s", metadata.Name, metadata.Type, plugin.PluginTypeTransform)
	}

	r.transforms = append(r.transforms, transform)
	return nil
}

// RegisterV2 adds a dependency-based transform plugin to the registry.
func (r *TransformRegistry) RegisterV2(transform TransformPluginV2) error {
	if transform == nil {
		return fmt.Errorf("cannot register nil transform")
	}

	metadata := transform.Metadata()
	if err := metadata.Validate(); err != nil {
		return fmt.Errorf("invalid transform metadata: %w", err)
	}

	// Verify it's a transform type
	if metadata.Type != plugin.PluginTypeTransform {
		return fmt.Errorf("plugin %s has type %s, expected %s", metadata.Name, metadata.Type, plugin.PluginTypeTransform)
	}

	r.transformsV2 = append(r.transformsV2, transform)
	return nil
}

// SetUseV2 enables the new dependency-based system.
func (r *TransformRegistry) SetUseV2(enabled bool) {
	r.useV2 = enabled
}

// GetUseV2 returns whether V2 system is enabled.
func (r *TransformRegistry) GetUseV2() bool {
	return r.useV2
}

// topologicalSortPlugins performs dependency resolution for plugin transforms.
func topologicalSortPlugins(transforms []TransformPluginV2) ([]TransformPluginV2, error) {
	if len(transforms) == 0 {
		return transforms, nil
	}

	// Build name -> transform map
	byName := make(map[string]TransformPluginV2)
	for _, t := range transforms {
		byName[t.Metadata().Name] = t
	}

	// Build adjacency list (dependencies graph)
	graph := make(map[string][]string)
	inDegree := make(map[string]int)

	for _, t := range transforms {
		name := t.Metadata().Name
		deps := t.Dependencies()

		if _, exists := graph[name]; !exists {
			graph[name] = []string{}
		}

		// Add edges for MustRunAfter
		for _, dep := range deps.MustRunAfter {
			if _, exists := byName[dep]; exists {
				graph[dep] = append(graph[dep], name)
				inDegree[name]++
			}
			// Skip if dependency not in this set (could be in different stage)
		}

		// Add edges for MustRunBefore
		for _, after := range deps.MustRunBefore {
			if _, exists := byName[after]; exists {
				graph[name] = append(graph[name], after)
				inDegree[after]++
			}
			// Skip if dependency not in this set
		}
	}

	// Kahn's algorithm for topological sort
	var queue []string
	for _, t := range transforms {
		name := t.Metadata().Name
		if inDegree[name] == 0 {
			queue = append(queue, name)
		}
	}

	// Sort queue for deterministic ordering
	sort.Strings(queue)

	var result []TransformPluginV2
	for len(queue) > 0 {
		// Pop from queue
		current := queue[0]
		queue = queue[1:]

		result = append(result, byName[current])

		// Process neighbors
		neighbors := graph[current]
		sort.Strings(neighbors) // Deterministic order

		for _, neighbor := range neighbors {
			inDegree[neighbor]--
			if inDegree[neighbor] == 0 {
				queue = append(queue, neighbor)
				sort.Strings(queue) // Keep queue sorted
			}
		}
	}

	// Check for cycles
	if len(result) != len(transforms) {
		return nil, fmt.Errorf("circular dependency detected in plugin transforms")
	}

	return result, nil
}

// ApplyToContent applies all registered transforms to content.
// Transforms are applied in order according to their Order() value (V1) or Dependencies (V2).
func (r *TransformRegistry) ApplyToContent(input *TransformInput) (*TransformResult, error) {
	result := &TransformResult{
		Content:  input.Content,
		Metadata: input.Metadata,
	}

	if r.useV2 {
		// Use V2 dependency-based ordering
		sorted, err := topologicalSortPlugins(r.transformsV2)
		if err != nil {
			return nil, fmt.Errorf("failed to sort transforms: %w", err)
		}

		for _, transform := range sorted {
			if !transform.ShouldApply(input) {
				continue
			}

			input.Content = result.Content
			input.Metadata = result.Metadata

			trResult := transform.Apply(input)
			if trResult.Error != nil {
				return nil, fmt.Errorf("transform %s failed: %w", transform.Metadata().Name, trResult.Error)
			}

			if !trResult.Skipped {
				result.Content = trResult.Content
				if trResult.Metadata != nil {
					for k, v := range trResult.Metadata {
						result.Metadata[k] = v
					}
				}
			}
		}
	} else {
		// Use V1 priority-based ordering (sort by Order())
		sorted := make([]TransformPlugin, len(r.transforms))
		copy(sorted, r.transforms)
		sort.Slice(sorted, func(i, j int) bool {
			return sorted[i].Order() < sorted[j].Order()
		})

		for _, transform := range sorted {
			if !transform.ShouldApply(input) {
				continue
			}

			input.Content = result.Content
			input.Metadata = result.Metadata

			trResult := transform.Apply(input)
			if trResult.Error != nil {
				return nil, fmt.Errorf("transform %s failed: %w", transform.Metadata().Name, trResult.Error)
			}

			if !trResult.Skipped {
				result.Content = trResult.Content
				if trResult.Metadata != nil {
					for k, v := range trResult.Metadata {
						result.Metadata[k] = v
					}
				}
			}
		}
	}

	return result, nil
}

// List returns all registered transforms.
func (r *TransformRegistry) List() []TransformPlugin {
	return r.transforms
}

// Count returns the number of registered transforms.
func (r *TransformRegistry) Count() int {
	return len(r.transforms)
}

// Clear removes all transforms from the registry.
func (r *TransformRegistry) Clear() {
	r.transforms = make([]TransformPlugin, 0)
}
