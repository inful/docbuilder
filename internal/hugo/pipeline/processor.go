package pipeline

import (
	"fmt"
	"log/slog"

	"git.home.luguber.info/inful/docbuilder/internal/config"
)

// Processor runs the complete content processing pipeline.
// It coordinates generators (create missing files) and transforms (modify content).
type Processor struct {
	config                *config.Config
	generators            []FileGenerator
	transforms            []FileTransform
	staticAssetGenerators []StaticAssetGenerator
}

// NewProcessor creates a new pipeline processor with default generators and transforms.
func NewProcessor(cfg *config.Config) *Processor {
	p := &Processor{
		config:                cfg,
		generators:            defaultGenerators(),
		transforms:            defaultTransforms(cfg),
		staticAssetGenerators: defaultStaticAssetGenerators(),
	}
	return p
}

// ProcessContent runs the complete content processing pipeline.
// This is the main entry point for content transformation.
//
// Pipeline phases:
// 1. Generation - Create missing files (indexes, etc.)
// 2. Transformation - Process all documents (discovered + generated)
//
// Returns processed documents ready for Hugo site generation.
func (p *Processor) ProcessContent(documents []*Document, repoMetadata map[string]RepositoryInfo, isSingleRepo bool) ([]*Document, error) {
	// Inject repository metadata (URL, commit) into discovered documents
	// This must happen before generation/transformation so edit links work correctly
	for _, doc := range documents {
		if doc.Repository != "" {
			if repoInfo, ok := repoMetadata[doc.Repository]; ok {
				doc.SourceURL = repoInfo.URL
				doc.SourceCommit = repoInfo.Commit
				doc.CommitDate = repoInfo.CommitDate
				doc.SourceBranch = repoInfo.Branch
			}
		}
	}

	// Phase 1: Generation - Create missing files
	slog.Info("Pipeline: Starting generation phase", slog.Int("discovered", len(documents)))

	ctx := &GenerationContext{
		Discovered:         documents,
		Config:             p.config,
		RepositoryMetadata: repoMetadata,
		IsSingleRepo:       isSingleRepo,
	}

	var generated []*Document
	for i, generator := range p.generators {
		docs, err := generator(ctx)
		if err != nil {
			return nil, fmt.Errorf("generator %d failed: %w", i, err)
		}
		if len(docs) > 0 {
			slog.Debug("Generator created files", slog.Int("count", len(docs)), slog.Int("generator", i))
		}
		generated = append(generated, docs...)
	}

	slog.Info("Pipeline: Generation phase complete", slog.Int("generated", len(generated)))

	// Phase 2: Transformation - Process all documents, including generated ones
	documents = append(documents, generated...)
	slog.Info("Pipeline: Starting transformation phase", slog.Int("total_docs", len(documents)))

	processedDocs, err := p.processTransforms(documents)
	if err != nil {
		return nil, fmt.Errorf("transformation phase failed: %w", err)
	}

	slog.Info("Pipeline: Transformation phase complete", slog.Int("processed", len(processedDocs)))

	return processedDocs, nil
}

// processTransforms runs all transforms on documents, handling dynamic document generation.
// New documents generated by transforms are queued and processed through the full pipeline.
func (p *Processor) processTransforms(docs []*Document) ([]*Document, error) {
	processedDocs := make([]*Document, 0, len(docs))
	queue := append([]*Document{}, docs...)
	processedCount := 0

	for len(queue) > 0 {
		doc := queue[0]
		queue = queue[1:]

		// Run all transforms on this document
		for i, transform := range p.transforms {
			newDocs, err := transform(doc)
			if err != nil {
				return nil, fmt.Errorf("transform %d failed for %s: %w", i, doc.Path, err)
			}

			// Prevent generated documents from creating new documents (infinite loop protection)
			if len(newDocs) > 0 && doc.Generated {
				return nil, fmt.Errorf(
					"generated document %s attempted to create new documents (transforms should not generate from generated docs)",
					doc.Path,
				)
			}

			// Queue new documents for full transform pipeline
			if len(newDocs) > 0 {
				slog.Debug("Transform generated new documents",
					slog.Int("count", len(newDocs)),
					slog.String("source", doc.Path),
					slog.Int("transform", i))
				queue = append(queue, newDocs...)
			}
		}

		processedDocs = append(processedDocs, doc)
		processedCount++

		// Log progress periodically
		if processedCount%100 == 0 {
			slog.Debug("Pipeline: Transform progress",
				slog.Int("processed", processedCount),
				slog.Int("queued", len(queue)))
		}
	}

	return processedDocs, nil
}

// WithGenerators replaces the default generators with custom ones.
// Useful for testing or custom build scenarios.
func (p *Processor) WithGenerators(generators []FileGenerator) *Processor {
	p.generators = generators
	return p
}

// WithTransforms replaces the default transforms with custom ones.
// Useful for testing or custom build scenarios.
func (p *Processor) WithTransforms(transforms []FileTransform) *Processor {
	p.transforms = transforms
	return p
}

// GenerateStaticAssets generates all static assets based on configuration.
// Returns a list of assets to be written to the Hugo site root.
func (p *Processor) GenerateStaticAssets() ([]*StaticAsset, error) {
	slog.Info("Pipeline: Generating static assets")

	ctx := &GenerationContext{
		Config: p.config,
	}

	// Use a map to handle duplicate paths. This enables the view transitions generator
	// (which runs after template metadata) to merge its content with the template metadata
	// partial generated earlier, creating a single custom-header.html with both features.
	assetMap := make(map[string]*StaticAsset)

	for i, generator := range p.staticAssetGenerators {
		assets, err := generator(ctx)
		if err != nil {
			return nil, fmt.Errorf("static asset generator %d failed: %w", i, err)
		}
		if len(assets) > 0 {
			slog.Debug("Static asset generator created assets",
				slog.Int("count", len(assets)),
				slog.Int("generator", i))
		}
		// Store assets by path (later generators overwrite earlier ones for same path)
		// This allows view transitions to merge with template metadata
		for _, asset := range assets {
			assetMap[asset.Path] = asset
		}
	}

	// Convert map back to slice
	allAssets := make([]*StaticAsset, 0, len(assetMap))
	for _, asset := range assetMap {
		allAssets = append(allAssets, asset)
	}

	slog.Info("Pipeline: Static asset generation complete", slog.Int("total", len(allAssets)))
	return allAssets, nil
}

// defaultGenerators returns the standard set of file generators.
// Order matters: main index → repository indexes → section indexes.
func defaultGenerators() []FileGenerator {
	return []FileGenerator{
		generateMainIndex,       // 1. Create site _index.md
		generateRepositoryIndex, // 2. Create repo _index.md files
		generateSectionIndex,    // 3. Create section _index.md files
	}
}

// defaultTransforms returns the standard set of content transforms.
// Order matters: this is the explicit, fixed pipeline execution order.
func defaultTransforms(cfg *config.Config) []FileTransform {
	return []FileTransform{
		parseFrontMatter,                  // 1. Parse YAML front matter from content
		normalizeIndexFiles,               // 2. Rename README to _index
		buildBaseFrontMatter,              // 3. Build base front matter structure
		extractIndexTitle,                 // 4. Extract H1 title from index files
		extractH1AsTitle,                  // 5. Extract H1 as title for all files (if no title)
		stripHeading,                      // 6. Strip H1 if appropriate
		escapeShortcodesInCodeBlocks,      // 7. Escape Hugo shortcodes in code blocks
		rewriteRelativeLinks(cfg),         // 8. Fix markdown links
		rewriteImageLinks,                 // 9. Fix image paths
		generateFromKeywords,              // 10. Create new files based on keywords (e.g., @glossary)
		addRepositoryMetadata(cfg),        // 11. Add repo/commit/source metadata
		addEditLink(cfg),                  // 12. Generate edit URL
		injectPermalink(cfg.Hugo.BaseURL), // 13. Append stable permalink badge
		serializeDocument,                 // 14. Serialize to final bytes (FM + content)
		fingerprintContent,                // 15. Add content fingerprint (must be last)
	}
}

// defaultStaticAssetGenerators returns the standard set of static asset generators.
func defaultStaticAssetGenerators() []StaticAssetGenerator {
	return []StaticAssetGenerator{
		generateTemplateMetadataAssets, // Always generate template metadata partial (required for template discovery)
		generateViewTransitionsAssets,  // Generate View Transitions API assets if enabled (will merge with template metadata)
	}
}
