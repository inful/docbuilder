package pipeline

import (
	"fmt"
	"slices"
	"strings"
)

// injectPermalink appends a copyable permalink badge to documents with a UID.
// It requires a non-empty "uid" field and a matching "/_uid/<uid>/" value in "aliases".
func injectPermalink(baseURL string) FileTransform {
	return func(doc *Document) ([]*Document, error) {
		if doc.Extension != ".md" || doc.Generated {
			return nil, nil
		}

		uid, _ := doc.FrontMatter["uid"].(string)
		uid = strings.TrimSpace(uid)
		if uid == "" {
			return nil, nil
		}

		aliasWant := "/_uid/" + uid + "/"
		if !hasAlias(doc.FrontMatter, aliasWant) {
			return nil, nil
		}

		// Construct full URL using baseURL.
		fullURL := strings.TrimRight(baseURL, "/") + aliasWant

		// Link name defaults to slugified title.
		linkName := "permalink"
		if title, ok := doc.FrontMatter["title"].(string); ok {
			if slugified := slugify(title); slugified != "" {
				linkName = slugified
			}
		}

		// Construct the badge shortcode.
		permalinkBadge := fmt.Sprintf(`{{%% badge style="note" title="permalink" %%}}`+"`[%s](%s)`"+`{{%% /badge %%}}`, linkName, fullURL)

		// Idempotence: don't add again if already present.
		if strings.Contains(doc.Content, `{{% badge style="note" title="permalink" %}}`) {
			return nil, nil
		}

		// Also check for legacy formats to maintain idempotence with files generated by older versions
		legacyFormats := []string{
			fmt.Sprintf("]({{%% ref %q %%}})", aliasWant),
			fmt.Sprintf("](%s)", aliasWant),
			fmt.Sprintf("](%s)", fullURL),
		}
		for _, f := range legacyFormats {
			if strings.Contains(doc.Content, f) {
				return nil, nil
			}
		}

		// Append to content
		trimmed := strings.TrimRight(doc.Content, "\r\n")
		doc.Content = trimmed + "\n\n" + permalinkBadge + "\n"

		return nil, nil
	}
}

// hasAlias reports whether the front matter "aliases" field contains the given value.
func hasAlias(fm map[string]any, want string) bool {
	v, exists := fm["aliases"]
	if !exists || v == nil {
		return false
	}

	switch aliases := v.(type) {
	case string:
		return aliases == want
	case []any:
		for _, a := range aliases {
			if s, ok := a.(string); ok && s == want {
				return true
			}
		}
	case []string:
		if slices.Contains(aliases, want) {
			return true
		}
	}
	return false
}

// slugify converts a string to a URL-friendly slug.
func slugify(s string) string {
	s = strings.ToLower(s)
	var b strings.Builder
	lastWasHyphen := false
	for _, r := range s {
		if (r >= 'a' && r <= 'z') || (r >= '0' && r <= '9') {
			b.WriteRune(r)
			lastWasHyphen = false
		} else if !lastWasHyphen && b.Len() > 0 {
			b.WriteRune('-')
			lastWasHyphen = true
		}
	}
	return strings.TrimRight(b.String(), "-")
}
