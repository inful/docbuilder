package integration

import (
	"os"
	"path/filepath"
	"testing"

	"github.com/stretchr/testify/require"

	"git.home.luguber.info/inful/docbuilder/internal/build"
	"git.home.luguber.info/inful/docbuilder/internal/config"
	"git.home.luguber.info/inful/docbuilder/internal/hugo"
	"git.home.luguber.info/inful/docbuilder/internal/lint"
)

// TestLintDocBuilderSync verifies that content generated by DocBuilder
// passes linting without errors. This ensures linting rules stay in sync
// with DocBuilder's actual output.
func TestLintDocBuilderSync(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	// Setup test repository
	repoPath := setupTestRepo(t, "../../test/testdata/repos/lint-sync-test")

	// Load configuration
	cfg := loadGoldenConfig(t, "../../test/testdata/configs/lint-sync.yaml")
	cfg.Repositories[0].URL = repoPath
	outputDir := t.TempDir()
	cfg.Output.Directory = outputDir

	// Run DocBuilder build pipeline
	svc := build.NewBuildService().
		WithHugoGeneratorFactory(func(cfgAny any, outDir string) build.HugoGenerator {
			return hugo.NewGenerator(cfgAny.(*config.Config), outDir)
		})

	result, err := svc.Run(t.Context(), build.BuildRequest{
		Config:    cfg,
		OutputDir: outputDir,
	})
	require.NoError(t, err, "DocBuilder build failed")
	require.Equal(t, build.BuildStatusSuccess, result.Status)

	// Verify generated Hugo site exists
	hugoContentDir := filepath.Join(outputDir, "content")
	require.DirExists(t, hugoContentDir, "Hugo content directory should exist")

	// Run linter on generated content
	linterCfg := &lint.Config{
		Format: "text",
		Quiet:  false,
	}
	linter := lint.NewLinter(linterCfg)

	lintResult, err := linter.LintPath(hugoContentDir)
	require.NoError(t, err, "Linting should not fail")

	// Assert that generated content passes all linting rules
	if lintResult.HasErrors() {
		t.Errorf("Generated content has linting errors:")
		for _, issue := range lintResult.Issues {
			if issue.Severity == lint.SeverityError {
				t.Logf("  %s:%d - %s: %s", issue.FilePath, issue.Line, issue.Rule, issue.Message)
			}
		}
		t.FailNow()
	}

	if lintResult.HasWarnings() {
		t.Logf("Generated content has warnings (non-blocking):")
		for _, issue := range lintResult.Issues {
			if issue.Severity == lint.SeverityWarning {
				t.Logf("  %s:%d - %s: %s", issue.FilePath, issue.Line, issue.Rule, issue.Message)
			}
		}
	}
}

// TestLintDocBuilderSync_FileNaming verifies that DocBuilder generates files
// with names that comply with linting conventions.
func TestLintDocBuilderSync_FileNaming(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	// Setup test repository
	repoPath := setupTestRepo(t, "../../test/testdata/repos/lint-sync-test")

	// Load configuration
	cfg := loadGoldenConfig(t, "../../test/testdata/configs/lint-sync.yaml")
	cfg.Repositories[0].URL = repoPath
	outputDir := t.TempDir()
	cfg.Output.Directory = outputDir

	// Run build
	svc := build.NewBuildService().
		WithHugoGeneratorFactory(func(cfgAny any, outDir string) build.HugoGenerator {
			return hugo.NewGenerator(cfgAny.(*config.Config), outDir)
		})

	result, err := svc.Run(t.Context(), build.BuildRequest{
		Config:    cfg,
		OutputDir: outputDir,
	})
	require.NoError(t, err)
	require.Equal(t, build.BuildStatusSuccess, result.Status)

	// Verify all generated files have compliant filenames
	hugoContentDir := filepath.Join(outputDir, "content")
	err = filepath.Walk(hugoContentDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() {
			return nil
		}

		// Apply filename rules
		filename := filepath.Base(path)
		if filepath.Ext(filename) == ".md" || filepath.Ext(filename) == ".markdown" {
			// Check filename convention
			if lint.HasFilenameIssue(filename) {
				t.Errorf("Generated file has naming issue: %s", path)
			}
		}
		return nil
	})
	require.NoError(t, err)
}
